{"version":3,"file":"urql-core.js","sources":["../src/utils/error.ts","../src/utils/hash.ts","../src/utils/stringifyVariables.ts","../src/utils/request.ts","../src/utils/result.ts","../src/utils/typenames.ts","../src/utils/maskTypename.ts","../src/utils/withPromise.ts","../src/exchanges/ssr.ts","../src/exchanges/cache.ts","../src/exchanges/debug.ts","../src/exchanges/dedup.ts","../src/exchanges/fetch.ts","../src/exchanges/fallback.ts","../src/exchanges/compose.ts","../src/exchanges/index.ts","../src/client.ts","../src/utils/toSuspenseSource.ts","../src/exchanges/subscription.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return x.toJSON();\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { DocumentNode, parse, print } from 'graphql';\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest, Operation, OperationContext } from '../types';\n\ninterface Documents {\n  [key: number]: DocumentNode;\n}\n\nconst hashQuery = (q: string): number => hash(q.replace(/[\\s,]+/g, ' ').trim());\n\nconst docs: Documents = Object.create(null);\nconst keyProp = '__key';\n\nexport const createRequest = (\n  q: string | DocumentNode,\n  vars?: object\n): GraphQLRequest => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hashQuery(q);\n    query = docs[key] !== undefined ? docs[key] : parse(q);\n  } else if ((q as any)[keyProp] !== undefined) {\n    key = (q as any)[keyProp];\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = docs[key] !== undefined ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  (query as any)[keyProp] = key;\n\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query,\n    variables: vars || {},\n  };\n};\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  source: Operation,\n  meta: Exclude<OperationContext['meta'], undefined>\n) => ({\n  ...source,\n  context: {\n    ...source.context,\n    meta: {\n      ...source.context.meta,\n      ...meta,\n    },\n  },\n});\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  visit,\n} from 'graphql';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: string[] = []) => {\n  if (Array.isArray(obj)) {\n    obj.forEach(inner => {\n      collectTypes(inner, types);\n    });\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types.push(obj[key] as string);\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  collectTypes(response as EntityLike).filter((v, i, a) => a.indexOf(v) === i);\n\nconst formatNode = (node: FieldNode | InlineFragmentNode) => {\n  if (\n    node.selectionSet &&\n    !node.selectionSet.selections.some(\n      node => node.kind === Kind.FIELD && node.name.value === '__typename'\n    )\n  ) {\n    // NOTE: It's fine to mutate here as long as we return the node,\n    // which will instruct visit() to clone the AST upwards\n    (node.selectionSet.selections as SelectionNode[]).push({\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: '__typename',\n      },\n    });\n\n    return node;\n  }\n};\n\nexport const formatDocument = (node: DocumentNode) => {\n  return visit(node, {\n    Field: formatNode,\n    InlineFragment: formatNode,\n  });\n};\n","export const maskTypename = (data: any): any => {\n  if (!data || typeof data !== 'object') return data;\n\n  return Object.keys(data).reduce((acc, key: string) => {\n    const value = data[key];\n    if (key === '__typename') {\n      Object.defineProperty(acc, '__typename', {\n        enumerable: false,\n        value,\n      });\n    } else if (Array.isArray(value)) {\n      acc[key] = value.map(maskTypename);\n    } else if (value && typeof value === 'object' && '__typename' in value) {\n      acc[key] = maskTypename(value);\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {});\n};\n","import { Source, pipe, toPromise, take } from 'wonka';\nimport { PromisifiedSource } from '../types';\n\nexport function withPromise<T>(source$: Source<T>): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () =>\n    pipe(source$, take(1), toPromise);\n  return source$ as PromisifiedSource<T>;\n}\n","import { GraphQLError } from 'graphql';\nimport { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error) {\n    result.error = {\n      graphQLErrors: error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n      networkError: error.networkError ? '' + error.networkError : undefined,\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: error\n      ? new CombinedError({\n          networkError: error.networkError\n            ? new Error(error.networkError)\n            : undefined,\n          graphQLErrors:\n            error.graphQLErrors && error.graphQLErrors.length\n              ? error.graphQLErrors\n              : undefined,\n        })\n      : undefined,\n  };\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op =>\n          op.operationName !== 'query' ||\n          op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n  const { additionalTypenames } = response.operation.context;\n\n  [\n    ...collectTypesFromResponse(response.data),\n    ...(additionalTypenames || []),\n  ].forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n  const { additionalTypenames } = operation.context;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  [\n    ...collectTypesFromResponse(response.data),\n    ...(additionalTypenames || []),\n  ].forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return (\n          operation.operationName === 'query' ||\n          operation.operationName === 'mutation'\n        );\n      }),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(\n          createFetchSource(\n            operation,\n            operation.operationName === 'query' &&\n              !!operation.context.preferGetMethod\n          ),\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return (\n          operation.operationName !== 'query' &&\n          operation.operationName !== 'mutation'\n        );\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node ? node.name!.value : null;\n};\n\nconst createFetchSource = (operation: Operation, shouldUseGet: boolean) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      ...extraOptions,\n      body: shouldUseGet ? undefined : JSON.stringify(body),\n      method: shouldUseGet ? 'GET' : 'POST',\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    if (shouldUseGet) {\n      operation.context.url = convertToGet(operation.context.url, body);\n    }\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => (ended ? undefined : executeFetch(operation, fetchOptions)))\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (\n  operation: Operation,\n  opts: RequestInit\n): Promise<OperationResult> => {\n  const { url, fetch: fetcher } = operation.context;\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, opts)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (opts.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    });\n};\n\nexport const convertToGet = (uri: string, body: Body): string => {\n  const queryParams: string[] = [`query=${encodeURIComponent(body.query)}`];\n\n  if (body.variables) {\n    queryParams.push(\n      `variables=${encodeURIComponent(JSON.stringify(body.variables))}`\n    );\n  }\n\n  return uri + '?' + queryParams.join('&');\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n  subscribe,\n  map,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport {\n  createRequest,\n  toSuspenseSource,\n  withPromise,\n  maskTypename,\n} from './utils';\n\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n  /** Use HTTP GET for queries. */\n  preferGetMethod?: boolean;\n  /** Mask __typename from results. */\n  maskTypename?: boolean;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  suspense: boolean;\n  preferGetMethod: boolean;\n  requestPolicy: RequestPolicy;\n  maskTypename: boolean;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation?: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n  queue: Operation[] = [];\n\n  constructor(opts: ClientOptions) {\n    if (process.env.NODE_ENV !== 'production' && !opts.url) {\n      throw new Error('You are creating an urql-client without a url.');\n    }\n\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n    this.preferGetMethod = !!opts.preferGetMethod;\n    this.maskTypename = !!opts.maskTypename;\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    let isDispatching = false;\n    this.dispatchOperation = (operation?: Operation) => {\n      if (!isDispatching) {\n        isDispatching = true;\n        if (operation) nextOperation(operation);\n        let queued: Operation | void;\n        while ((queued = this.queue.shift())) nextOperation(queued);\n        isDispatching = false;\n      } else if (operation) {\n        nextOperation(operation);\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    const exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    preferGetMethod: this.preferGetMethod,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    let operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (this.maskTypename) {\n      operationResults$ = pipe(\n        operationResults$,\n        map(res => {\n          res.data = maskTypename(res.data);\n          return res;\n        })\n      );\n    }\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.queue.push(operation);\n      this.dispatchOperation();\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  readQuery<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data> | null {\n    let result: OperationResult<Data> | null = null;\n\n    pipe(\n      this.executeQuery(createRequest(query, variables), context),\n      subscribe(res => {\n        result = res;\n      })\n    ).unsubscribe();\n\n    return result;\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n","import { pipe, share, onPush, toPromise, takeWhile, take, Source } from 'wonka';\n\n/** This converts a Source to a suspense Source; It will forward the first result synchronously or throw a promise that resolves when the result becomes available */\nexport const toSuspenseSource = <T>(source: Source<T>): Source<T> => sink => {\n  const shared = share(source);\n  let hasResult = false;\n  let hasSuspended = false;\n\n  pipe(\n    shared,\n    takeWhile(() => !hasSuspended),\n    onPush(() => (hasResult = true))\n  )(sink);\n\n  if (!hasResult) {\n    hasSuspended = true;\n    sink(0); /* End */\n    throw pipe(shared, take(1), toPromise);\n  }\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n\n  /** This flag may be turned on to allow your subscriptions-transport to handle all operation types */\n  enableAllOperations?: boolean;\n}\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n      let sub;\n\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n\n        sub = observableish.subscribe({\n          next: result => next(makeResult(operation, result)),\n          error: err => next(makeErrorResult(operation, err)),\n          complete: () => {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.operationName === 'subscription') {\n                client.reexecuteOperation({\n                  ...operation,\n                  operationName: 'teardown',\n                });\n              }\n\n              complete();\n            }\n          },\n        });\n      });\n\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n\n  const isSubscriptionOperation = (operation: Operation): boolean => {\n    const { operationName } = operation;\n    return (\n      operationName === 'subscription' ||\n      (!!enableAllOperations &&\n        (operationName === 'query' || operationName === 'mutation'))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n"],"names":["const","rehydrateGraphQlError","error","GraphQLError","this","CombinedError","message","networkErr","graphQlErrs","undefined","err","generateErrorMessage","networkError","normalizedGraphQLErrors","response","Error","phash","h","x","i","l","seen","Set","cache","WeakMap","stringify","JSON","Array","out","value","Object","key","Math","keys","stringifyVariables","hashQuery","q","hash","docs","createRequest","vars","parse","print","query","variables","addMetadata","source","meta","_extends","context","makeResult","operation","result","data","graphQLErrors","extensions","makeErrorResult","collectTypes","obj","types","inner","v","a","collectTypesFromResponse","node","Kind","formatNode","kind","name","formatDocument","visit","Field","InlineFragment","maskTypename","acc","enumerable","source$","toPromise","take","shouldSkip","operationName","path","op","cacheOutcome","cacheExchange","cachedResult","resultCache","reexecuteOperation","client","isOperationCached","handleAfterMutation","handleAfterQuery","Map","mapTypeNames","afterMutation","operationCache","afterQuery","requestPolicy","ops$","sharedOps$","share","map","filter","tap","forward","merge","cachedOps$","forwardedOps$","pendingOperations","additionalTypenames","typeName","console","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","forward$","fetchExchange","mergeMap","teardown$","takeUntil","createFetchSource","fetchResults$","shouldUseGet","process","make","abortController","AbortController","getOperationName","body","fetchOptions","extraOptions","method","headers","signal","convertToGet","ended","executeFetch","next","complete","opts","statusNotOk","fetch","res","uri","queryParams","encodeURIComponent","fallbackExchangeIO","composeExchanges","exchanges","payload","exchange","defaultExchanges","Client","url","preferGetMethod","type","request","response$","switchMap","fromValue","interval","pollInterval","makeSubject","isDispatching","nextOperation","queued","prevActive","operationResults$","onStart","onEnd","sink","shared","hasResult","hasSuspended","takeWhile","toSuspenseSource","result$","suspense","withPromise","params","isCached","deserialized","deserializeResult","serialized","serializeResult","ssr","isClient","restore","enableAllOperations","isSubscriptionOperation","createSubscriptionSource","observableish","forwardSubscription","isComplete","sub","subscriptionResults$"],"mappings":"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"}